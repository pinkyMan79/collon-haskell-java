# Colon Interpreter

**Colon** — это интерпретатор для языка программирования в стиле Forth. Он поддерживает стековые вычисления и выполняет команды с использованием стека. Этот интерпретатор был разработан для практики работы с функциональными языками и монадами в Haskell.

---

## Оглавление

1. [Описание языка Colon](#описание-языка-colon)
2. [Функциональность интерпретатора](#функциональность-интерпретатора)
3. [Основные компоненты реализации](#основные-компоненты-реализации)
4. [Пример использования](#пример-использования)
5. [Тонкости реализации](#тонкости-реализации)
6. [Запуск программы](#запуск-программы)
7. [Контакты](#контакты)

---

## Описание языка Colon

**Colon** — минималистичный язык программирования, который работает на основе стека. Каждая операция берет данные из стека, выполняет вычисления и возвращает результат обратно в стек. Основные особенности языка:

- **Простые арифметические операции**: сложение, вычитание, умножение, деление, модуль.
- **Логические операции**: сравнение, логическое "и", "или", инверсия.
- **Операции со стеком**: `DUP`, `DROP`, `SWAP`, `OVER`, `ROT`.
- **Управляющие конструкции**: условные выражения (`IF ELSE THEN`), циклы (`DO LOOP`, `BEGIN UNTIL`).
- **Определение переменных и констант**.
- **Работа с массивами**: создание, чтение и запись.
- **Возможность расширения** через пользовательские слова.

---

## Функциональность интерпретатора

Интерпретатор поддерживает следующие возможности:

- **Обработка стека**: выполнение всех операций над стеком.
- **Определение слов (функций)**: создание новых слов с помощью `: <имя> ... ;`.
- **Переменные и константы**:
  - Переменные создаются с помощью `VARIABLE` и изменяются командами `!` (установка) и `@` (чтение).
  - Константы определяются через `CONSTANT`.
- **Арифметика и логика**: включает базовые арифметические и логические операции.
- **Циклы и условия**:
  - Условные конструкции реализованы через `IF ELSE THEN`.
  - Циклы реализованы через `DO LOOP`, а также `BEGIN UNTIL`.
- **Работа с массивами**: поддерживаются команды создания массивов, чтения и изменения их элементов.

---

## Основные компоненты реализации

### 1. **Структуры данных**
- **`Stack`**: стек для выполнения операций (список `Int`).
- **`Dictionary`**: словарь, содержащий определения пользовательских слов.
- **`StateColon`**: структура состояния, включающая стек, словарь и память для переменных.

### 2. **Тип данных `Command`**
`Command` представляет одну инструкцию языка Colon. Основные варианты:
- **Арифметические команды**: `Add`, `Sub`, `Mul`, `Div`, `Mod`.
- **Логические операции**: `Equals`, `Less`, `Greater`, `And`, `Or`, `Invert`.
- **Операции со стеком**: `Dup`, `Drop`, `Swap`, `Over`, `Rot`.
- **Ввод-вывод**: `Dot`, `Emit`, `CR`, `DotString`.
- **Условные конструкции**: `If`, `DoLoop`, `Begin`, `Until`.
- **Работа с памятью**: `Variable`, `Set`, `Get`, `Constant`.
- **Работа с массивами**: `NewArray`, `Index`, `SetIndex`.
- **Пользовательские слова**: `Word`, `Call`.

### 3. **Monad ColonM**
Используется для управления состоянием (`StateT`) и обработки ошибок (`ExceptT`).

### 4. **Функции**
- **`execute`**: выполняет отдельную команду.
- **`interpret`**: интерпретирует входную строку и выполняет команды.
- **`parse`**: парсинг программы в список команд.

Функции являются основой работы интерпретатора. Рассмотрим ключевые функции: `execute`, `interpret` и `parse`. Каждая из них отвечает за выполнение своей части процесса интерпретации программы на языке **Colon**.

---

#### **`execute`**
Эта функция выполняет одну команду на стековой машине, изменяя состояние стека и памяти. Вот как она реализована:

1. **Тип команды**  
   Функция принимает команду (`Command`) и текущее состояние (`StateColon`).

2. **Алгоритм работы**  
   Для каждой команды происходит сопоставление с шаблоном. Основные случаи:
   - **Арифметические операции**:
     ```haskell
     execute Add = do
         (x:y:rest) <- popTwo
         push (x + y)
     ```
     Если операция `Add`, то два верхних элемента снимаются со стека (через `popTwo`), складываются и результат помещается обратно в стек.

   - **Логические операции**:
     ```haskell
     execute Equals = do
         (x:y:rest) <- popTwo
         push (if x == y then 1 else 0)
     ```
     Для сравнения `Equals` верхние два элемента проверяются на равенство, результат (`1` или `0`) кладётся в стек.

   - **Операции со стеком**:
     ```haskell
     execute Dup = do
         x <- pop
         push x
         push x
     ```
     Команда `DUP` дублирует верхний элемент стека.

   - **Работа с переменными**:
     ```haskell
     execute (Set varName) = do
         val <- pop
         setVariable varName val
     ```
     Для команды установки значения переменной (`Set`) элемент снимается со стека и сохраняется в переменную с именем `varName`.

   - **Условные конструкции**:
     ```haskell
     execute (If thenBranch elseBranch) = do
         cond <- pop
         if cond /= 0
             then executeCommands thenBranch
             else executeCommands elseBranch
     ```
     Условие проверяет значение на вершине стека. Если оно не равно `0`, выполняется ветка `thenBranch`, иначе — `elseBranch`.

   - **Циклы**:
     ```haskell
     execute (DoLoop start end commands) = do
         forM_ [start..end-1] $ \i -> do
             setIndex i
             executeCommands commands
     ```
     Цикл `DoLoop` выполняет набор команд для каждого значения из указанного диапазона.

  - **Циклы с `Begin...Until`**
    `Begin...Until` — это конструкция цикла, в которой команды выполняются до тех пор, пока условие не станет истинным (ненулевым).  

    Пример реализации:  
    ```haskell
    execute (BeginUntil commands) = do
    let loop = do
        executeCommands commands
        cond <- pop
        when (cond == 0) loop
    loop
    ```


# Работа с массивами

Поддержка массивов добавляет возможность создания, чтения и записи значений по индексам.

## Создание массива

Команда `NewArray` создаёт массив из заданного количества элементов, которые инициализируются нулями.

Пример реализации:

```haskell
execute (NewArray n) = modifyStack $ \stack -> Right (replicate n 0 ++ stack)
```

- **Как это работает**:
  1. Создаётся массив размером `n` с элементами, равными нулю.
  2. Этот массив помещается на вершину стека.

## Чтение элемента массива по индексу

Команда `Index` позволяет прочитать элемент массива по заданному индексу.

Пример реализации:

```haskell
execute (Index i) = modifyStack $ \case
    (arr : xs) -> Right (arr !! i : xs)
    _ -> Left "Stack underflow"
```

- **Как это работает**:
  1. На вершине стека должен быть массив.
  2. Получаем значение массива на позиции `i` и помещаем его обратно на стек.

## Запись значения по индексу

Команда `SetIndex` заменяет элемент массива на заданной позиции значением, которое находится на вершине стека.

Пример реализации:

```haskell
execute (SetIndex i) = modifyStack $ \case
    (val : arr : xs) -> Right (take i arr ++ [val] ++ drop (i + 1) arr : xs)
    _ -> Left "Stack underflow"
```

- **Как это работает**:
  1. На вершине стека должен быть массив и индекс.
  2. Записываем значение из вершины стека на указанную позицию в массиве.
  3. Массив с обновлённым значением снова помещается на стек.

    
3. **Ошибки**  
   Если во время выполнения команды стек оказывается пустым или команда некорректна, выбрасывается ошибка через `ExceptT`.

---

#### **`interpret`**
Эта функция отвечает за интерпретацию строки с программой. Она разбивает входной текст, парсит команды и выполняет их.

1. **Алгоритм работы**:
   - **Парсинг строки**:
     ```haskell
     interpret input = do
         let commands = parse input
         executeCommands commands
     ```
     Строка передаётся на парсинг с помощью функции `parse`. Результатом будет список команд.

   - **Выполнение списка команд**:
     ```haskell
     executeCommands :: [Command] -> ColonM ()
     executeCommands [] = return ()
     executeCommands (cmd:cmds) = do
         execute cmd
         executeCommands cmds
     ```
     Для каждой команды из списка вызывается `execute`. Процесс продолжается до тех пор, пока не будут выполнены все команды.

2. **Ошибки парсинга**  
   Если ввод содержит ошибку (например, неизвестные команды), интерпретатор возвращает сообщение об ошибке.

3. **Пример вызова**:
   ```text
   interpret "5 10 + ."

---

## Пример использования

### Примеры программ

1. Арифметические операции:
   ```text
   5 10 + .

### Послесловие. Отчёт по курсу ФП Haskell

Курс мне очень зашёл, особенно из-за того, что было много чего удивительного для меня, например:  
- **Отсутствие циклов и использование только рекурсии**.  
  Это стало для меня настоящим открытием. Несмотря на первое ощущение сложности, со временем я осознал, насколько это мощный и выразительный инструмент. Вместо типичных циклов я научился смотреть на задачи как на преобразования данных через рекурсию. 

- **Огромное количество синтаксических "приколюх"**, как например, функторы.  
  Вначале меня немного пугала абстрактность таких концепций, как `Functor`, `Applicative`. Но потом я осознал их огромный потенциал, особенно при использовании в обработке данных. Каждая из этих концепций добавляет новый уровень выразительности в написании функционального кода.

- **Многообразие подходов к написанию кода**.  
  Хочешь, пиши через `)` — хочешь через `$`, или вообще используй `.` (композицию функций). Эта гибкость позволяет адаптировать стиль написания к личным предпочтениям или ситуации. Например, использование `$` для устранения лишних скобок сделало код намного более читаемым. А оператор `.` для композиции функций позволил создавать более лаконичные и цепочки преобразований.

### Что особенно впечатлило в Haskell

- **Чистота и лаконичность кода**.  
  Haskell заставляет думать о том, что и как ты пишешь. Благодаря типам и строгим принципам, ошибки отлавливаются на этапе компиляции, что делает код более надежным.  

- **Ленивая семантика (Lazy evaluation)**.  
  Это просто магия: функции вызываются только тогда, когда они действительно нужны. Это не только позволило мне больше узнать о теории вычислений, но и помогло понять, как такие подходы можно использовать для работы с большими объемами данных.  

- **Типы и система типов**.  
  Типы в Haskell — это как документация внутри кода. Работая с ними, я стал писать более структурированный и безопасный код. Особо хочется отметить `Maybe` и `Either`, которые помогли мне избавиться от "ничего не значащих" значений вроде `null` и научиться писать выразительный код для обработки ошибок.

- **Сложность и мощь абстракций**.  
  Многие темы, такие как монады или монадические трансформеры, изначально казались сложными. Но освоив их, я начал лучше понимать, как строить сложные программы, сохраняя их модульными и управляемыми.  

- **Функциональный стиль мышления**.  
  Курс научил меня мыслить "функциями", а не процедурами. Вместо того чтобы описывать последовательность действий, я стал задумываться о преобразованиях данных. Огромное колличесто тем около дата инженеринга стало понятнее, как например концепция map-reduce

### Одно Но
- **Возникают вопросы к синтаксису работы с массивами и коллекциями**
  Мне не совсем понятно почему решили сделать именно такой синтаксис как напрмер !! или :. Я конечно могу вывести это более удобочиаемые функции как например getByIndex или pop, но всё же не понятно почему так решили сделать, так как неподготовленный любитель ооп от таких приколов может просто расплакаться

### Личное впечатление

Честно говоря, я был удивлен, насколько Haskell изменил мой подход к программированию. Вначале он казался мне сложным, но со временем его принципы и идеи начали "срастаться" с моим мышлением. Это не просто язык программирования, а целая философия, которая заставляет смотреть на задачи под другим углом.  

Теперь я уверен, что даже если не буду использовать Haskell в повседневной работе, его идеи и подходы останутся со мной. Они уже повлияли на мой стиль программирования в других языках, помогли мне писать более выразительный, чистый и безопасный код. Как минимум в Java ( мой основной яп ) я стал больше пользоваться функциональным стилем вне StreamAPI
